{
   "intents": [
      {
         "tag": "greeting",
         "patterns": [
            "bonjour",
            "Bonjour",
            "Salut",
            "Coucou",
            "Hello",
            "Bonjour, comment ça va ?"
         ],
         "responses": [
            "Bonjour ! Comment puis-je vous aider aujourd'hui ?",
            "Salut ! Que puis-je faire pour vous ?",
            "Coucou ! En quoi puis-je vous assister ?"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "goodbye",
         "patterns": [
            "Au revoir",
            "À plus tard",
            "Bye",
            "Ciao",
            "Je m'en vais"
         ],
         "responses": [
            "Au revoir ! À bientôt.",
            "À plus tard ! N'hésitez pas à revenir si vous avez des questions.",
            "Bye ! Passez une excellente journée."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "thanks",
         "patterns": [
            "Merci",
            "Merci beaucoup",
            "Je vous remercie",
            "Super, merci !"
         ],
         "responses": [
            "Je vous en prie !",
            "Avec plaisir !",
            "Pas de problème, heureux de vous aider."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "aes_details",
         "patterns": [
            "Détails sur AES-256",
            "Pourquoi AES est-il considéré comme sécurisé ?",
            "Histoire d'Advanced Encryption Standard",
            "Implémentation matérielle d'AES"
         ],
         "responses": [
            "AES utilise une structure de réseau de substitution-permutation avec des tours de chiffrement variables : 10 pour 128-bit, 12 pour 192-bit, 14 pour 256-bit.",
            "Approuvé par la NSA pour les informations top secret, résistant aux attaques par canaux auxiliaires lorsqu'implémenté correctement."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "rsa_limitations",
         "patterns": [
            "Faiblesses du RSA",
            "Attaques potentielles contre RSA",
            "Pourquoi RSA-1024 est déconseillé ?",
            "Facteur de dépréciation RSA"
         ],
         "responses": [
            "RSA devient vulnérable avec l'avènement de l'informatique quantique (algorithme de Shor) et nécessite des tailles de clés ≥2048 bits aujourd'hui.",
            "Les erreurs d'implémentation (padding PKCS#1 v1.5) peuvent conduire à des vulnérabilités comme Bleichenbacher's attack."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "quantum_crypto",
         "patterns": [
            "Impact de l'informatique quantique sur le chiffrement",
            "Algorithmes post-quantiques",
            "Résistance quantique de AES",
            "Cryptographie lattice-based"
         ],
         "responses": [
            "NIST a sélectionné Kyber (échange de clés) et Dilithium (signatures) comme standards post-quantiques en 2022.",
            "AES-256 reste considéré quantique-sûr avec un doublement de la taille de clé, contrairement à RSA/ECC qui sont vulnérables."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "tls_handshake",
         "patterns": [
            "Étapes d'un handshake TLS 1.3",
            "Différence entre TLS 1.2 et 1.3",
            "Forward secrecy explication",
            "Elliptic curves in TLS"
         ],
         "responses": [
            "TLS 1.3 simplifie le handshake à 1 aller-retour et supprime les algorithmes obsolètes (SHA-1, RC4, CBC mode).",
            "X25519 est la courbe elliptique préférée pour l'échange de clés dans les implémentations modernes."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "password_hashing",
         "patterns": [
            "Fonctions de hachage adaptées aux mots de passe",
            "Paramètres idéaux pour Argon2",
            "Pourquoi bcrypt est préférable à SHA-256 ?",
            "Pepper vs salt"
         ],
         "responses": [
            "Utilisez Argon2id avec au moins 64 Mo de mémoire, 3 itérations et 4 parallélismes pour les mots de passe.",
            "Un pepper global ajoute une couche de sécurité supplémentaire mais nécessite une gestion sécurisée."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_misuse",
         "patterns": [
            "Erreurs courantes en implémentation cryptographique",
            "Pourquoi l'ECB est dangereux ?",
            "Gestion incorrecte des IV",
            "Problèmes de synchronisation GCM"
         ],
         "responses": [
            "L'utilisation d'un IV fixe ou prédictible dans CBC/CTR/GCM compromet totalement la confidentialité.",
            "La réutilisation d'un nonce avec AES-GCM expose la clé d'authentification à des attaques cryptanalytiques."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "hardware_security",
         "patterns": [
            "Rôle des TPM dans le chiffrement",
            "HSM vs SGX",
            "Secure enclave Apple",
            "Protection des clés matérielles"
         ],
         "responses": [
            "Les HSM (Hardware Security Modules) fournissent une isolation physique des clés avec des certifications FIPS 140-2/3.",
            "Les enclaves sécurisées (comme Intel SGX) permettent un traitement isolé des données sensibles même sur machine compromise."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_audit",
         "patterns": [
            "Vérifier la solidité cryptographique",
            "Outils d'analyse de chiffrement",
            "Tests de pénétration cryptographiques",
            "Certification FIPS"
         ],
         "responses": [
            "Utilisez CryptCheck (cryptcheck.fr) pour analyser la configuration TLS d'un serveur.",
            "L'outil Cryptofuzz permet de détecter les vulnérabilités dans les implémentations cryptographiques."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "side_channels",
         "patterns": [
            "Attaques par canaux auxiliaires",
            "Prévention des timing attacks",
            "Cache-based attacks",
            "Déduction d'information par consommation électrique"
         ],
         "responses": [
            "Les implémentations doivent utiliser un code à temps constant pour les opérations sensibles (vérification MAC, comparaisons).",
            "Les attaques Spectre/Meltdown exploitent les optimisations matérielles pour fuiter des données cryptographiques."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "zero_knowledge",
         "patterns": [
            "Preuves à divulgation nulle de connaissance",
            "Applications ZKP en cryptographie",
            "zk-SNARKs explication",
            "Protocole Sigma"
         ],
         "responses": [
            "Les ZKP permettent de vérifier une connaissance secrète sans la révéler, utilisé dans Zcash et des systèmes de voting.",
            "Bulletproofs permettent des preuves compactes de plage de valeurs sans configuration de confiance."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "blockchain_crypto",
         "patterns": [
            "Cryptographie dans Bitcoin",
            "Fonctionnement des signatures ECDSA",
            "Adresses bitcoin dérivation",
            "Sécurité des wallets matériels"
         ],
         "responses": [
            "Bitcoin utilise secp256k1 pour les signatures et SHA-256 double pour l'extraction de clés (BIP32).",
            "Les wallets HD (BIP44) permettent une gestion hiérarchique déterministe des clés avec une seed unique."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "vpn_protocols",
         "patterns": [
            "Différence entre IPSec et WireGuard",
            "Chiffrement dans OpenVPN",
            "Protocole Noise pour VPN",
            "Forward secrecy dans les VPN"
         ],
         "responses": [
            "WireGuard utilise Noise Protocol Framework avec ChaCha20, Poly1305 et Curve25519 pour une simplicité sécurisée.",
            "IPSec en mode transport avec AES-GCM-256 et PFS via DH group 19 est recommandé pour les entreprises."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_policies",
         "patterns": [
            "Régulation du chiffrement en UE",
            "Loi française sur le chiffrement",
            "Export controls cryptographiques",
            "Position de l'IETF sur le backdooring"
         ],
         "responses": [
            "Le Règlement eIDAS 2.0 prévoit des portes dérobées contrôlées pour les communications (article 45 controversé).",
            "Les normes ITAR aux USA classifient le chiffrement comme munition, nécessitant des licences d'exportation."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "secure_messaging",
         "patterns": [
            "Protocole Signal Protocol",
            "Fonctionnement de Matrix avec E2EE",
            "Comparaison Signal/Telegram/WhatsApp",
            "Vulnérabilités de Telegram"
         ],
         "responses": [
            "Signal utilise le Double Ratchet avec X3DH pour l'échange initial et des clés éphémères par message.",
            "Telegram utilise un chiffrement maison non vérifié (MTProto) avec des risques potentiels de conception."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_history",
         "patterns": [
            "Origines de la cryptographie moderne",
            "Rôle d'Alan Turing dans le chiffrement",
            "Évolution de DES à AES",
            "Histoire de la cryptographie quantique"
         ],
         "responses": [
            "La machine Enigma et son décryptage par l'équipe de Bletchley Park ont marqué un tournant pendant la WWII.",
            "Le DES (1976) fut le premier standard public, cassé par DES Challenge III en 22 heures en 1999."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_libraries",
         "patterns": [
            "Comparaison OpenSSL vs LibreSSL",
            "Sécurité de la bibliothèque Bouncy Castle",
            "Utilisation de sodium en Python",
            "Erreurs courantes dans les wrappers cryptographiques"
         ],
         "responses": [
            "LibreSSL est un fork sécurisé d'OpenSSL après Heartbleed, avec une réduction drastique de la surface d'attaque.",
            "La librairie libsodium (NaCl) fournit des primitives modernes et sûres par défaut (ChaCha20-Poly1305, Argon2)."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_standards",
         "patterns": [
            "Processus de standardisation NIST",
            "Critères communs pour les modules cryptographiques",
            "Certification FIPS 140-3",
            "Norme ISO/IEC 19790"
         ],
         "responses": [
            "Le NIST organise des compétitions ouvertes (comme pour AES et SHA-3) pour sélectionner les standards.",
            "FIPS 140-3 niveau 3 exige une protection physique contre les intrusions avec détection de compromission."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "randomness",
         "patterns": [
            "Génération de nombres aléatoires sécurisés",
            "Problèmes avec /dev/urandom",
            "Utilisation de TRNG matériels",
            "Attaques contre PRNG défectueux"
         ],
         "responses": [
            "Sur Linux moderne, /dev/urandom est sûr après le premier boot grâce à l'entropie accumulée.",
            "Les CSRNG (Cryptographically Secure RNG) doivent utiliser des sources d'entropie multiples et un bon mixing."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_attacks",
         "patterns": [
            "Attaque ROCA contre les clés RSA",
            "Fonctionnement de Heartbleed",
            "DROWN attack sur SSLv2",
            "POODLE et les vulnérabilités CBC"
         ],
         "responses": [
            "ROCA (CVE-2017-15361) exploitait une vulnérabilité dans les clés RSA générées par Infineon TPMs.",
            "Heartbleed (CVE-2014-0160) permettait l'exfiltration de 64Ko de mémoire via une extension TLS mal implémentée."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "homomorphic_enc",
         "patterns": [
            "Chiffrement homomorphe explication",
            "Applications pratiques du FHE",
            "Performances du chiffrement homomorphe",
            "Bibliothèques open source pour FHE"
         ],
         "responses": [
            "Le FHE (Fully Homomorphic Encryption) permet des calculs sur données chiffrées mais nécessite 1 million de fois plus de ressources.",
            "Microsoft SEAL et IBM HELib sont des implémentations de référence pour la recherche en FHE."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_infra",
         "patterns": [
            "PKI (Infrastructure à clés publiques)",
            "Fonctionnement d'une autorité de certification",
            "Déploiement de certificats ACME",
            "Gestion des révocation CRL/OCSP"
         ],
         "responses": [
            "Let's Encrypt utilise le protocole ACME pour automatiser l'émission de certificats TLS gratuits.",
            "OCSP Stapling permet de vérifier la validité d'un certificat sans fuite de confidentialité de la consultation."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_protocols",
         "patterns": [
            "Protocole Diffie-Hellman",
            "Signal Protocol explication",
            "Sécurité de OAuth2/JWT",
            "Fonctionnement de Kerberos"
         ],
         "responses": [
            "Diffie-Hellman Ephemeral (DHE) fournit le forward secrecy en générant des clés éphémères par session.",
            "Kerberos utilise des tickets chiffrés symétriquement et un serveur d'authentification central (KDC)."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_analysis",
         "patterns": [
            "Méthodes de cryptanalyse moderne",
            "Attaques par force brute optimisées",
            "Analyse différentielle/linéaire",
            "Modèle de menace pour les systèmes cryptographiques"
         ],
         "responses": [
            "L'attaque biclique réduit la complexité de brute-force sur AES-128 à 2^126.1 opérations (théorique).",
            "Les attaques par canaux auxiliaires nécessitent un accès physique au dispositif de chiffrement."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_quantique",
         "patterns": [
            "Cryptographie basée sur les principes quantiques",
            "Distribution quantique de clés (QKD)",
            "Intrication quantique en cryptographie",
            "Limites pratiques de la crypto quantique"
         ],
         "responses": [
            "Le protocole BB84 utilise la polarisation de photons pour échanger des clés de manière inviolable (en théorie).",
            "Les systèmes QKD commerciaux comme ceux d'ID Quantique atteignent des débits de 1 Mbps sur 100 km de fibre."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_mobile",
         "patterns": [
            "Sécurité cryptographique Android/iOS",
            "Hardware keystore mobile",
            "Chiffrement de fichier sur mobile",
            "Biométrie et stockage des clés"
         ],
         "responses": [
            "Android KeyStore permet de stocker des clés matérielles avec authentification biométrique sans les exposer au SO.",
            "L'élément sécurisé (Secure Enclave) des iPhones isole les opérations cryptographiques même si le SOC est compromis."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_cloud",
         "patterns": [
            "BYOK (Bring Your Own Key) dans le cloud",
            "Services KMS d'AWS/GCP/Azure",
            "Chiffrement côté client avant upload",
            "Accès sécurisé aux secrets cloud"
         ],
         "responses": [
            "AWS KMS utilise des HSM validés FIPS 140-2 niveau 3 avec audit trail via CloudTrail.",
            "Les solutions comme HashiCorp Vault fournissent une gestion centralisée des secrets avec chiffrement dynamique."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "cryptographie_symetrique",
         "patterns": [
            "Principe du chiffrement symétrique",
            "Avantages AES vs DES",
            "Modes d'opération des chiffrements par blocs",
            "Théorie mathématique derrière le chiffrement symétrique"
         ],
         "responses": [
            "Les chiffrements symétriques utilisent la même clé pour chiffrer/déchiffrer. AES utilise une structure de réseau de substitution-permutation basée sur :\n- Addition matricielle dans GF(2^8)\n- MixColumns utilisant la multiplication par une matrice MDS\n- Key Schedule avec rotation de mots et S-Box",
            "Théorème de Shannon : Un système est parfaitement secret si |K| ≥ |M| et chaque clé est utilisée une fois (one-time pad)"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "cryptographie_asymetrique",
         "patterns": [
            "Fondements mathématiques de RSA",
            "Problème du logarithme discret",
            "Courbes elliptiques en cryptographie",
            "Comparaison RSA vs ECC"
         ],
         "responses": [
            "RSA repose sur la difficulté de factoriser n = p*q. Clé publique : (n, e)\nClé privée : d ≡ e⁻¹ mod φ(n)\nChiffrement : c ≡ m^e mod n\nDéchiffrement : m ≡ c^d mod n",
            "ECC utilise le groupe des points d'une courbe y² = x³ + ax + b sur F_p. La sécurité vient de la difficulté du problème ECDLP : Étant donné P et Q = kP, trouver k"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "protocoles_echange_cles",
         "patterns": [
            "Protocole Diffie-Hellman",
            "Attaques MITM sur les échanges de clés",
            "Authentification dans les échanges",
            "Forward Secrecy"
         ],
         "responses": [
            "Diffie-Hellman épelémère :\n1. Alice et Bob choisissent (g, p)\n2. Alice → a ← random, envoie g^a mod p\n3. Bob → b ← random, envoie g^b mod p\n4. Clé partagée : g^(ab) mod p",
            "Forward Secrecy : Utilisation de clés éphémères pour empêcher la compromission rétroactive. Implémentation avec DHE ou ECDHE"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "fonctions_de_hachage",
         "patterns": [
            "Construction de Merkle-Damgård",
            "Résistance aux collisions SHA-256",
            "Applications des fonctions de hachage",
            "Attaques par extension de longueur"
         ],
         "responses": [
            "SHA-256 utilise :\n- Padding avec longueur du message\n- Compression via fonction de tour avec additions mod 2³² et opérations bitwise\n- Constantes initiales dérivées des racines cubiques des premiers",
            "Théorème de l'anniversaire : Pour une fonction de hachage de sortie n bits, une collision est probable après ≈2^(n/2) essais"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "cryptanalyseque",
         "patterns": [
            "Méthode de Wiener sur RSA",
            "Attaque par canaux auxiliaires",
            "Analyse différentielle sur DES",
            "Cryptanalyse linéaire"
         ],
         "responses": [
            "Attaque de Wiener sur RSA : Si d < (1/3)N^(1/4), on peut retrouver d via l'approximation de e/N par fraction continue",
            "Cryptanalyse différentielle :\n1. Recherche de paires de textes clairs avec différence Δ\n2. Analyse des différences de textes chiffrés\n3. Dérivation de bits de clé via les caractéristiques différentielles"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_post_quantique",
         "patterns": [
            "Algorithmes résistants aux ordinateurs quantiques",
            "Cryptographie basée sur les réseaux euclidiens",
            "Problème LWE (Learning With Errors)",
            "Signature numérique post-quantique"
         ],
         "responses": [
            "NIST Post-Quantum Standardization :\n- Kyber (échange de clés lattice-based)\n- Dilithium (signatures lattice-based)\n- SPHINCS+ (signatures hash-based)",
            "Problème LWE : Étant donné (A, As + e) où A ∈ ℤ_q^(m×n), s ∈ ℤ_q^n, e ← χ^m, retrouver s. La sécurité repose sur la difficulté de résoudre des systèmes linéaires avec bruit"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_homomorphe",
         "patterns": [
            "Calcul sur données chiffrées",
            "Schémas FHE (Fully Homomorphic Encryption)",
            "Applications pratiques",
            "Limites de performance"
         ],
         "responses": [
            "Schéma BFV (Brakerski/Fan-Vercauteren) :\n- Chiffrement : c = (m + e + p·s) mod q\n- Opérations via addition/multiplication polynomiale dans R_q = ℤ_q[x]/(x^n +1)",
            "Bootstrapping : Technique permettant de réduire le bruit accumulé pendant les calculs, rendant le FHE théoriquement illimité"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "zero_knowledge_proofs",
         "patterns": [
            "Protocole Schnorr",
            "zk-SNARKs applications",
            "Preuves interactives vs non-interactives",
            "Setup de confiance"
         ],
         "responses": [
            "Protocole Schnorr :\n1. Prover choisit r ← random, envoie R = g^r\n2. Verifier envoie challenge c\n3. Prover répond s = r + c·x\n4. Verifier vérifie g^s = R·y^c où y = g^x",
            "zk-SNARKs utilisent :\n- QAP (Quadratic Arithmetic Programs)\n- Pairing cryptographique\n- CRS (Common Reference String)"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_visuelle",
         "patterns": [
            "Schémas de partage secret visuel",
            "Stéganographie mathématique",
            "Code de Reed-Solomon en imagerie",
            "Watermarking numérique"
         ],
         "responses": [
            "Partage secret (k,n) de Shamir :\n- Le secret S est encodé comme f(0) où f(x) = a_0 + a_1x + ... + a_{k-1}x^{k-1}\n- Chaque partie reçoit un point (x_i, f(x_i))",
            "Code correcteur Reed-Solomon :\n- Opère sur GF(2^m)\n- Capacité de correction t = (n-k)/2 symboles\n- Utilisé dans QR Codes et stockage"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_quantique",
         "patterns": [
            "Distribution quantique de clés BB84",
            "Intrication quantique en crypto",
            "Limites physiques QKD",
            "Attaques PNS (Photon Number Splitting)"
         ],
         "responses": [
            "Protocole BB84 :\n1. Alice envoie des photons polarisés dans une base aléatoire {+,×}\n2. Bob mesure dans une base aléatoire\n3. Reconciliation et privacy amplification",
            "Théorème de non-clonage quantique : Impossible de copier un état quantique inconnu, garantissant la détection d'écoute"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_analyse_complexite",
         "patterns": [
            "Classes de complexité cryptographiques",
            "Problèmes NP-complets en crypto",
            "Réduction polynomiale",
            "Hypothèse exponentielle time"
         ],
         "responses": [
            "Hiérarchie des problèmes :\n- P : Décidable en temps polynomial\n- NP : Vérifiable en temps poly\n- BQP : Résoluble par ordinateur quantique",
            "Hypothèse cryptographique standard :\nAucun algorithme probabiliste polynomial (PPT) ne peut résoudre un problème (ex. factorisation) avec probabilité non négligeable"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "signatures_digitales",
         "patterns": [
            "Schéma ECDSA",
            "Preuve de sécurité EUF-CMA",
            "Attaques sur signatures faibles",
            "EdDSA vs Schnorr"
         ],
         "responses": [
            "ECDSA signature :\n1. Calculer h = H(m)\n2. Choisir k aléatoire\n3. Calculer (r, s) où r = x-coord([k]G)\n   s = k⁻¹(h + r·d) mod n\nVérification : [s⁻¹h]G + [s⁻¹r]Q = R",
            "Sécurité EUF-CMA (Existential Unforgeability under Chosen Message Attacks) : Impossible de forger une signature même après requêtes à un oracle de signature"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_implementation",
         "patterns": [
            "Protection contre les attaques temporelles",
            "Code à temps constant",
            "Sécurité des bibliothèques cryptographiques",
            "Erreurs classiques d'implémentation"
         ],
         "responses": [
            "Comparaison sécurisée :\nAu lieu de 'if (a == b)', utiliser 'return ct_equal(a, b) & mask'\nOù ct_equal est une comparaison à temps constant",
            "Vulnérabilités courantes :\n- Fuite de mémoire (Heartbleed)\n- Gestion incorrecte des erreurs (Padding Oracle)\n- Génération aléatoire faible"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_histoire",
         "patterns": [
            "Évolution historique des chiffrements",
            "Machines Enigma et Lorenz",
            "Contribution d'Alan Turing",
            "Naissance de la cryptographie moderne"
         ],
         "responses": [
            "Analyse d'Enigma :\n- Utilisait 3 rotors parmi 5 (10 combinaisons)\n- Tableau de connexions (Stecker)\n- Faiblesse : Aucune lettre ne s'auto-chiffre\nSolution par Bombe de Turing-Welchman",
            "DES (Data Encryption Standard) :\n- Développé par IBM comme Lucifer\n- Clé 56 bits, 16 tours de Feistel\n- Cassé par DES Challenge III en 1999 (22h)"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "symmetric_vs_asymmetric",
         "patterns": [
            "Différence entre chiffrement symétrique et asymétrique",
            "Avantages RSA vs AES",
            "Quand utiliser un chiffrement symétrique ?",
            "Comparaison clé publique/privée"
         ],
         "responses": [
            "Le chiffrement symétrique (AES) est rapide mais nécessite un échange sécurisé de clés. L'asymétrique (RSA) permet l'échange sécurisé mais est plus lent. Solution hybride recommandée : ECDH pour l'échange + AES-GCM pour le chiffrement.",
            "Performances :\n- AES-256 : ~200 MB/s (matériel)\n- RSA-2048 : ~1000 opérations/s\nUtilisez RSA pour les petits payloads (clés de session) et AES pour les données volumineuses"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "hash_functions",
         "patterns": [
            "Fonction de hachage cryptographique",
            "Propriétés de SHA-256",
            "Résistance à la préimage",
            "Construction de Merkle-Damgård"
         ],
         "responses": [
            "Une fonction de hachage sécurisée doit vérifier :\n1. Résistance à la préimage (H(m) → m)\n2. Résistance aux collisions (H(m1) = H(m2))\n3. Effet avalanche (1 bit changé → 50% bits modifiés)",
            "SHA-256 :\n- Taille de bloc 512 bits\n- 64 tours de transformation\n- Sortie 256 bits\n- Basé sur la construction Merkle-Damgård"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "digital_signatures",
         "patterns": [
            "Fonctionnement des signatures numériques",
            "Protocole ECDSA explication",
            "Vérification signature RSA",
            "Preuve non-répudiation"
         ],
         "responses": [
            "Processus de signature :\n1. Hacher le message (SHA-256)\n2. Chiffrer le hash avec la clé privée\n3. Joindre la signature au message\nVérification : Déchiffrer avec la clé publique et comparer les hashs",
            "ECDSA paramètres :\n- Courbe elliptique secp256k1 (Bitcoin)\n- Clé privée : entier aléatoire d\n- Clé publique : Q = d×G (point de la courbe)"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_protocols",
         "patterns": [
            "Protocole SSL/TLS explication",
            "Étapes handshake HTTPS",
            "Authentification mutuelle SSL",
            "Forward secrecy implémentation"
         ],
         "responses": [
            "TLS 1.3 Handshake :\n1. ClientHello (cipher suites supportés)\n2. ServerHello (suite choisie + certificat)\n3. Key Exchange (ECDHE)\n4. Authentification\n5. Application Data (chiffré avec AES-GCM)",
            "Forward Secrecy :\n- Utilisation de clés éphémères (DHE/ECDHE)\n- Régénération de clés par session\n- Protection contre la compromission future"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "cryptanalysis",
         "patterns": [
            "Méthodes de cryptanalyse classiques",
            "Attaque par force brute AES",
            "Analyse différentielle explication",
            "Faiblesse ECB mode"
         ],
         "responses": [
            "Cryptanalyse AES :\n- Attaque biclique : complexité 2^126.1 pour AES-128\n- Attaque par canaux auxiliaires (timing, consommation)\n- Impossible differential (7 tours pour AES-128)",
            "ECB vulnérable car :\n- Pas d'IV\n- Patterns visibles dans le texte chiffré\n- Permet l'altération de blocs individuels"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "post_quantum",
         "patterns": [
            "Algorithmes post-quantiques NIST",
            "Sécurité lattice-based cryptography",
            "Kyber vs RSA comparaison",
            "Signature Dilithium explication"
         ],
         "responses": [
            "NIST PQC Finalists :\n- CRYSTALS-Kyber (Key Encapsulation)\n- CRYSTALS-Dilithium (Signatures)\n- Falcon (Signatures basées sur NTRU)\n- SPHINCS+ (Signatures hash-based)",
            "Kyber-768 :\n- Clé publique : 1 568 bytes\n- Clé privée : 1 600 bytes\n- Sécurité équivalente à AES-192\n- Basé sur MLWE (Module Learning With Errors)"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_courses",
         "patterns": [
            "Meilleurs cours de cryptographie",
            "Livres recommandés en crypto",
            "MOOC cryptographie appliquée",
            "Programme universitaire cryptologie"
         ],
         "responses": [
            "Ressources académiques :\n1. 'Introduction to Modern Cryptography' (Lindell-Katz)\n2. Cours Stanford (Dan Boneh) sur Coursera\n3. Cryptopals Crypto Challenges\n4. Master Cryptologie à l'ENS",
            "Programme typique :\n- Théorie des nombres\n- Algèbre linéaire avancée\n- Complexité algorithmique\n- Implémentation sécurisée\n- Cryptanalyse pratique"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_math",
         "patterns": [
            "Mathématiques pour la cryptographie",
            "Théorie des groupes en crypto",
            "Fonctions trapdoor explication",
            "Corps finis GF(p^n)"
         ],
         "responses": [
            "Concepts clés :\n- Arithmétique modulaire\n- Groupes cycliques (ℤ_p*, courbes elliptiques)\n- Polynômes irréductibles\n- Logarithme discret\n- Résidus quadratiques",
            "Exemple de fonction trapdoor :\nRSA : m^e mod n → facile\nInverse : c^(1/e) mod n → difficile sans factorization"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "caesar_cipher",
         "patterns": [
            "Expliquez le chiffrement de César",
            "Comment fonctionne le chiffre de César ?",
            "Méthode de chiffrement par décalage",
            "ROT13 explication",
            "Exemple de chiffre de César"
         ],
         "responses": [
            "Le chiffre de César est un chiffrement par substitution où chaque lettre est décalée d'un nombre fixe de positions. Exemple avec un décalage de 3 : 'BONJOUR' → 'ERQMRXU'. Pour déchiffrer, on applique un décalage inverse.",
            "ROT13 est un cas particulier du chiffre de César avec un décalage de 13 positions. Avantage : l'opération est son propre inverse puisque 13+13=26 (nombre de lettres). Exemple : 'CRYPTO' → 'PELCGB'."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "vigenere_cipher",
         "patterns": [
            "Chiffre de Vigenère explication",
            "Fonctionnement du chiffrement Vigenère",
            "Attaques contre Vigenère",
            "Avantages de Vigenère vs César",
            "Exemple de chiffrement Vigenère"
         ],
         "responses": [
            "Le chiffre de Vigenère utilise une clé pour appliquer différents décalages de César à chaque lettre. Exemple : texte 'CRYPTOGRAPHIE' avec clé 'CLE' :\nC+C=F, R+L=C, Y+E=C... donnant 'FCCRXSKKDTJMG'.\nFormule : C_i = (P_i + K_i mod m) mod 26 où K_i est répété cycliquement.",
            "Vigenère est vulnérable à l'analyse de fréquence si la longueur de clé est connue. La méthode de Kasiski (recherche de répétitions) et l'indice de coïncidence permettent d'estimer cette longueur, puis d'analyser chaque sous-séquence comme un chiffre de César."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "playfair_cipher",
         "patterns": [
            "Chiffre de Playfair explication",
            "Tableau Playfair construction",
            "Règles du chiffrement Playfair",
            "Avantages de Playfair",
            "Exemple Playfair complet"
         ],
         "responses": [
            "Le chiffre de Playfair utilise une grille 5×5 basée sur une clé, où I/J sont combinés. Règles :\n1. Diviser le texte en bigrammes\n2. Si même ligne : prendre lettres à droite (circulaire)\n3. Si même colonne : prendre lettres en dessous\n4. Sinon : former rectangle et prendre coins opposés\nExemple avec clé 'CRYPTO' :\nGrille:\nC R Y P T\nO A B D E\nF G H I/J K\nL M N Q S\nU V W X Z",
            "Pour chiffrer 'BONJOUR' avec Playfair :\n1. BO → B et O ne sont ni sur la même ligne ni la même colonne → prendre coins opposés : B→D, O→F → 'DF'\n2. NJ → 'GE'\n3. OU → 'DK'\n4. UR → (ajout X pour lettre isolée) → 'SY RK'\nRésultat : 'DFGEDKSY'"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "aes_example",
         "patterns": [
            "Exemple concret de chiffrement AES",
            "Code AES en Python/JavaScript",
            "Étapes AES avec valeurs",
            "AES-128 vs AES-256 exemple",
            "Démonstration AES"
         ],
         "responses": [
            "Exemple AES-128 en Python :\n```python\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nfrom Crypto.Random import get_random_bytes\n\n# Clé 128 bits (16 octets)\nkey = get_random_bytes(16)\n\n# Vecteur d'initialisation (pour CBC)\niv = get_random_bytes(16)\n\n# Texte à chiffrer\ndata = b'Donnees secretes a proteger'\n\n# Chiffrement (mode CBC)\ncipher = AES.new(key, AES.MODE_CBC, iv)\nct_bytes = cipher.encrypt(pad(data, AES.block_size))\n\n# Pour déchiffrer\ncipher = AES.new(key, AES.MODE_CBC, iv)\npt = unpad(cipher.decrypt(ct_bytes), AES.block_size)\n```",
            "Implémentation AES-GCM (authentifié) :\n```javascript\nconst crypto = require('crypto');\n\n// Clé et nonce aléatoires\nconst key = crypto.randomBytes(32); // AES-256\nconst nonce = crypto.randomBytes(12); // 96 bits recommandés pour GCM\n\n// Chiffrement\nconst cipher = crypto.createCipheriv('aes-256-gcm', key, nonce);\nlet encrypted = cipher.update('Message secret', 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconst authTag = cipher.getAuthTag();\n\n// Déchiffrement avec vérification\nconst decipher = crypto.createDecipheriv('aes-256-gcm', key, nonce);\ndecipher.setAuthTag(authTag);\nlet decrypted = decipher.update(encrypted, 'hex', 'utf8');\ndecrypted += decipher.final('utf8');\n```"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "rsa_example",
         "patterns": [
            "Exemple concret de RSA",
            "Génération clés RSA pas à pas",
            "Chiffrement RSA avec nombres",
            "Code RSA en Python",
            "Calcul RSA manuel"
         ],
         "responses": [
            "Exemple RSA simplifié :\n1. Choisir p=11, q=13 (petits pour l'exemple)\n2. n = p×q = 143\n3. φ(n) = (p-1)(q-1) = 10×12 = 120\n4. Choisir e=7 (premier avec 120)\n5. Calculer d: 7×d ≡ 1 (mod 120) → d = 103\n\nClé publique : (n=143, e=7)\nClé privée : (n=143, d=103)\n\nPour chiffrer m=9 :\nc = m^e mod n = 9^7 mod 143 = 48\n\nPour déchiffrer c=48 :\nm = c^d mod n = 48^103 mod 143 = 9",
            "Implémentation RSA en Python :\n```python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_OAEP\nfrom Crypto.Signature import pkcs1_15\nfrom Crypto.Hash import SHA256\n\n# Génération de clés (2048 bits recommandé minimum)\nkey = RSA.generate(2048)\npub_key = key.publickey()\n\n# Sauvegarder les clés\nwith open('private.pem', 'wb') as f:\n    f.write(key.export_key('PEM'))\nwith open('public.pem', 'wb') as f:\n    f.write(pub_key.export_key('PEM'))\n\n# Chiffrement (avec padding OAEP)\nmessage = b'Message secret'\ncipher = PKCS1_OAEP.new(pub_key)\nciphertext = cipher.encrypt(message)\n\n# Déchiffrement\ncipher = PKCS1_OAEP.new(key)\nplaintext = cipher.decrypt(ciphertext)\n\n# Signature\nhash_obj = SHA256.new(message)\nsignature = pkcs1_15.new(key).sign(hash_obj)\n\n# Vérification\ntry:\n    pkcs1_15.new(pub_key).verify(hash_obj, signature)\n    print(\"Signature valide\")\nexcept:\n    print(\"Signature invalide\")\n```"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "substitution_cipher",
         "patterns": [
            "Chiffrement par substitution simple",
            "Monoalphabétique vs polyalphabétique",
            "Faiblesse des chiffrements par substitution",
            "Analyse fréquentielle explication",
            "ROT13 vs substitution"
         ],
         "responses": [
            "Le chiffrement par substitution remplace chaque lettre par une autre selon une table de correspondance. Exemple avec la clé 'CRYPTOGAHIEBNDFQJKLMSVWXUZ' :\nA→C, B→R, C→Y... donc 'BONJOUR' → 'RQGTQBO'\nPlus général que César mais vulnérable à l'analyse de fréquence.",
            "Analyse fréquentielle : En français, les lettres les plus fréquentes sont E, A, S, I, N, T, R, U, L, O. Dans un texte chiffré par substitution, on identifie les caractères les plus fréquents et on tente de les faire correspondre, en tenant compte des bigrammes (comme 'ES', 'LE') et des modèles comme les mots courts ('LE', 'DE', 'UN')."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "transposition_cipher",
         "patterns": [
            "Chiffrement par transposition explication",
            "Chiffre de permutation",
            "Méthode du rail fence",
            "Scytale spartiate",
            "Exemple chiffre de route"
         ],
         "responses": [
            "Le chiffrement par transposition réarrange les lettres sans les modifier. Exemple avec une clé numérique [3,1,4,2] :\n1. Écrire le message en colonnes de longueur 4\n2. Lire les colonnes selon l'ordre de la clé\nPour 'CRYPTOGRAPHIE' :\nC  R  Y  P\nT  O  G  R\nA  P  H  I\nE  _  _  _\nLecture : colonne 3, puis 1, puis 4, puis 2 → 'YCARPH_POG_IE_'",
            "Rail fence (zigzag) : Exemple avec 3 rails et message 'CRYPTOGRAPHIE' :\nC     O     P\n R   T   A   I\n  Y P   G R   E\nLecture par rail : 'COPRTAIYPGRE'\nUtilisé historiquement pour sa simplicité, mais facilement cassable."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "diffie_hellman_example",
         "patterns": [
            "Diffie-Hellman exemple concret",
            "Calcul Diffie-Hellman pas à pas",
            "Échange de clés DH avec nombres",
            "ECDH exemple simple",
            "Man in the middle Diffie-Hellman"
         ],
         "responses": [
            "Exemple Diffie-Hellman avec petits nombres :\n1. Paramètres publics : p=23 (premier), g=5 (générateur)\n2. Alice : clé privée a=6, envoie A = g^a mod p = 5^6 mod 23 = 8\n3. Bob : clé privée b=15, envoie B = g^b mod p = 5^15 mod 23 = 19\n4. Alice calcule : B^a mod p = 19^6 mod 23 = 2\n5. Bob calcule : A^b mod p = 8^15 mod 23 = 2\nClé partagée = 2\n\nMême avec p, g, A et B publics, un attaquant doit résoudre le problème du logarithme discret.",
            "Pour plus de sécurité, on utilise aujourd'hui ECDH (courbes elliptiques) avec des courbes comme X25519 :\n```javascript\nconst crypto = require('crypto');\n\n// Alice génère une paire de clés\nconst aliceKeys = crypto.generateKeyPairSync('x25519');\n\n// Bob génère une paire de clés\nconst bobKeys = crypto.generateKeyPairSync('x25519');\n\n// Alice calcule la clé commune\nconst aliceShared = crypto.diffieHellman({\n  privateKey: aliceKeys.privateKey,\n  publicKey: bobKeys.publicKey\n});\n\n// Bob calcule la clé commune\nconst bobShared = crypto.diffieHellman({\n  privateKey: bobKeys.privateKey,\n  publicKey: aliceKeys.publicKey\n});\n\n// aliceShared === bobShared (même clé secrète)\n```"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "historical_ciphers",
         "patterns": [
            "Méthodes de chiffrement historiques",
            "ADFGVX chiffre allemand",
            "Chiffre de Vernam",
            "Enigma fonctionnement",
            "Évolution des chiffrements"
         ],
         "responses": [
            "Le chiffre ADFGVX (1918) combinait substitution et transposition :\n1. Grille 6×6 contenant l'alphabet et les chiffres\n2. Chaque caractère remplacé par 2 lettres parmi A, D, F, G, V, X\n3. Résultat transposé avec une clé\nUtilisé par l'armée allemande pendant la Première Guerre mondiale, déchiffré par Georges Painvin.",
            "Le carré de Polybe (2e siècle av. J.-C.) codait chaque lettre par ses coordonnées dans une grille 5×5 :\n  1 2 3 4 5\n1 A B C D E\n2 F G H I/J K\n3 L M N O P\n4 Q R S T U\n5 V W X Y Z\nExemple : 'BONJOUR' → '21 34 33 24 34 45 42'\nBase de nombreux chiffrements plus sophistiqués."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "one_time_pad",
         "patterns": [
            "Masque jetable (one-time pad)",
            "Chiffre de Vernam sécurité",
            "Chiffrement parfaitement sûr",
            "Problèmes pratiques du OTP",
            "Exemple de one-time pad"
         ],
         "responses": [
            "Le masque jetable (OTP) est le seul chiffrement prouvé mathématiquement incassable (Shannon, 1949) si :\n1. La clé est totalement aléatoire\n2. La clé est aussi longue que le message\n3. La clé n'est jamais réutilisée\n4. La clé reste secrète\n\nExemple :\nMessage : 'CRYPTO' = [2, 17, 24, 15, 19, 14]\nClé : 'SXWPKT' = [18, 23, 22, 15, 10, 19]\nChiffré = (M+K) mod 26 = [20, 14, 20, 4, 3, 7] = 'UOUEDH'",
            "Inconvénients du masque jetable :\n1. Distribution sécurisée des clés volumineuses\n2. Génération de bits véritablement aléatoires\n3. Stockage sécurisé des clés\n4. Synchronisation des clés entre participants\n\nUtilisation historique : Télétype rouge reliant Washington et Moscou pendant la Guerre froide."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "enigma_machine",
         "patterns": [
            "Machine Enigma explication",
            "Fonctionnement des rotors Enigma",
            "Comment Turing a cassé Enigma",
            "Paramètres d'Enigma",
            "Simuler Enigma"
         ],
         "responses": [
            "Enigma (utilisée par l'Allemagne nazie) fonctionnait avec :\n1. Un clavier (entrée)\n2. Un tableau de connexions (Steckerbrett) : permutation initiale\n3. Trois rotors mobiles (ou plus) : chaque rotor effectue une substitution\n4. Un réflecteur : permutation supplémentaire avec retour\n5. Un tableau lumineux (sortie)\n\nChaque pression sur une touche fait tourner au moins un rotor, changeant la substitution à chaque lettre.",
            "Attaque d'Enigma par Turing :\n1. Exploitation de messages stéréotypés (cribs)\n2. Invention de la Bombe : machine électromécanique recherchant les paramètres\n3. Utilisation des faiblesses : aucune lettre ne s'encode en elle-même\n4. Analyse statistique pour réduire l'espace de recherche\n\nCette cryptanalyse à Bletchley Park aurait raccourci la guerre de 2-4 ans selon les historiens."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "hash_examples",
         "patterns": [
            "Exemples concrets de hachage",
            "Code SHA-256 en pratique",
            "Vérification d'intégrité par hash",
            "Salt et hash pour mots de passe",
            "Arbre de Merkle exemple"
         ],
         "responses": [
            "Exemple SHA-256 en Python :\n```python\nimport hashlib\n\n# Hachage simple\ntexte = \"Bonjour le monde\"\nhash_sha256 = hashlib.sha256(texte.encode()).hexdigest()\nprint(f\"SHA-256: {hash_sha256}\")\n\n# Hachage sécurisé de mot de passe avec sel\nimport os\nfrom hashlib import pbkdf2_hmac\n\nmot_de_passe = \"MonMotDePasse123\"\nsel = os.urandom(16)  # 16 octets de sel aléatoire\n\n# 100 000 itérations de PBKDF2 avec SHA-256\nhash_mdp = pbkdf2_hmac('sha256', mot_de_passe.encode(), sel, 100000)\n\n# Pour stocker: sel + hash\nresultat = sel + hash_mdp\n```",
            "Vérification d'intégrité de fichier :\n```bash\n# Génération du hash\nsha256sum fichier.iso > fichier.iso.sha256\n\n# Vérification ultérieure\nsha256sum -c fichier.iso.sha256\n```\n\nArbre de Merkle (utilisé dans Bitcoin) :\n1. Hacher chaque bloc de données\n2. Combiner les hashs par paires et hacher à nouveau\n3. Répéter jusqu'à obtenir un seul hash racine\nPermet de vérifier efficacement l'appartenance d'un élément à un ensemble."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "elliptic_curve",
         "patterns": [
            "Courbes elliptiques expliquées simplement",
            "ECDSA vs RSA avantages",
            "Courbe secp256k1 Bitcoin",
            "Addition de points sur courbe elliptique",
            "Exemple concret ECC"
         ],
         "responses": [
            "Les courbes elliptiques en cryptographie utilisent l'équation y² = x³ + ax + b sur un corps fini. Avantages vs RSA :\n- Clés plus courtes (256 bits ECC ≈ 3072 bits RSA)\n- Plus rapide pour la même sécurité\n- Meilleure pour les appareils contraints (IoT, cartes à puce)\n\nCourbes populaires :\n- secp256k1 (Bitcoin)\n- Curve25519/Ed25519 (TLS, SSH)\n- P-256 (standards NIST)",
            "Opérations sur courbe elliptique :\n1. Addition P + Q : tracer une ligne entre P et Q, trouver le 3e point d'intersection, réfléchir par rapport à l'axe x\n2. Doubler P : tracer la tangente à P, trouver l'intersection, réfléchir\n3. Multiplication scalaire kP : ajouter P à lui-même k fois (optimisé)\n\nLa sécurité repose sur le problème du logarithme discret : étant donné P et Q = kP, trouver k est difficile."
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "steganography",
         "patterns": [
            "Stéganographie vs cryptographie",
            "Cacher des données dans une image",
            "Techniques de stéganographie",
            "Stéganographie LSB",
            "Détection de stéganographie"
         ],
         "responses": [
            "La stéganographie cache l'existence même du message, contrairement au chiffrement qui cache son contenu. Techniques courantes :\n1. LSB (Least Significant Bit) : modification des bits de poids faible dans les pixels d'une image\n2. DCT (Discrete Cosine Transform) : altération des coefficients DCT dans JPEG\n3. Insertion dans les métadonnées (EXIF, commentaires)\n4. Utilisation d'espaces invisibles ou formatage dans du texte",
            "Exemple de stéganographie LSB en Python :\n```python\nfrom PIL import Image\n\ndef text_to_bits(text):\n    bits = ''\n    for char in text:\n        bits += format(ord(char), '08b')\n    return bits\n\ndef hide_message(img_path, message, output_path):\n    img = Image.open(img_path)\n    width, height = img.size\n    pixels = list(img.getdata())\n    \n    # Convertir le message en bits\n    binary_message = text_to_bits(message) + '1111111111111110'  # Délimiteur\n    \n    if len(binary_message) > len(pixels) * 3:\n        raise ValueError(\"Message trop long\")\n    \n    # Modifier les bits de poids faible\n    new_pixels = []\n    bit_index = 0\n    \n    for pixel in pixels:\n        new_pixel = list(pixel)\n        for i in range(3):  # RGB\n            if bit_index < len(binary_message):\n                # Remplacer le LSB\n                new_pixel[i] = new_pixel[i] & ~1 | int(binary_message[bit_index])\n                bit_index += 1\n        new_pixels.append(tuple(new_pixel))\n    \n    # Créer la nouvelle image\n    new_img = Image.new(img.mode, img.size)\n    new_img.putdata(new_pixels)\n    new_img.save(output_path)\n```"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "cryptographic_attacks",
         "patterns": [
            "Types d'attaques cryptographiques",
            "Attaque par dictionnaire",
            "Attaque de l'homme du milieu",
            "Attaque par canal auxiliaire",
            "Attaque par rejeu"
         ],
         "responses": [
            "Principales attaques cryptographiques :\n1. Brute force : essai systématique de toutes les clés\n2. Dictionnaire : essai de mots courants, variantes et fuites\n3. Rainbow tables : précalcul de hashs (contré par salage)\n4. Homme du milieu (MITM) : interception active des communications\n5. Canaux auxiliaires : analyse du timing, consommation électrique\n6. Rejeu : réutilisation d'un message légitime intercepté",
            "Contre-mesures essentielles :\n1. Brute force : clés longues, KDF lents (Argon2)\n2. Dictionnaire : politiques de mots de passe forts\n3. Rainbow tables : sel unique par hash\n4. MITM : authentification mutuelle, HSTS\n5. Canaux auxiliaires : implémentations à temps constant\n6. Rejeu : nonces/timestamps uniques, jetons de session"
         ],
         "context": [
            ""
         ]
      },
      {
         "tag": "crypto_projects",
         "patterns": [
            "Projets pour apprendre la cryptographie",
            "Implémentations pédagogiques",
            "Exercices cryptographie débutant",
            "CTF cryptographiques",
            "Outils pour pratiquer"
         ],
         "responses": [
            "Projets pratiques pour apprendre :\n1. Implémenter César, Vigenère, AES simplifiés\n2. Créer un gestionnaire de mots de passe\n3. Système de chat chiffré de bout en bout\n4. Blockchain minimaliste\n5. Certificats auto-signés et PKI simple\n6. Authentification par challenge-réponse\n\nOutils : CyberChef, cryptii.com, dCode",
            "Ressources pour s'entraîner :\n1. Cryptopals Crypto Challenges (cryptopals.com)\n2. CryptoHack (cryptohack.org)\n3. CTF de picoCTF (section cryptographie)\n4. Root Me (cryptanalyse)\n5. WeChall (challenges progressifs)\n6. 'The Code Book' de Simon Singh (avec challenges)\n\nCommencer par comprendre les chiffrements historiques développe l'intuition pour les systèmes modernes."
         ],
         "context": [
            ""
         ]
      }
   ]
}
